diff --git a/src/executors/rollup/lib/update-package-json.js b/src/executors/rollup/lib/update-package-json.js
index 120cc0f682b3b98da42a5e1257f7f27e3b4c8b3b..844a8b9b3eb6849852ab130f5313d32fa1aa33cc 100644
--- a/src/executors/rollup/lib/update-package-json.js
+++ b/src/executors/rollup/lib/update-package-json.js
@@ -17,58 +17,43 @@ function updatePackageJson(options, packageJson) {
     if (hasEsmFormat) {
         const esmExports = getExports({
             ...options,
-            fileExt: '.esm.js',
+            fileExt: (hasCjsFormat && packageJson.type !== 'module') ? '.esm.mjs' : '.js',
         });
-        packageJson.module = esmExports['.'];
+        packageJson.module = esmExports['.']['jsFile'];
         if (!hasCjsFormat) {
             packageJson.type = 'module';
-            packageJson.main ??= esmExports['.'];
+            packageJson.main ??= esmExports['.']['jsFile'];
+            packageJson.types ??= esmExports['.']['typesFile'];
         }
         if (options.generateExportsField) {
-            for (const [exportEntry, filePath] of Object.entries(esmExports)) {
-                packageJson.exports[exportEntry] = hasCjsFormat
-                    ? // If CJS format is used, make sure `import` (from Node) points to same instance of the package.
-                        // Otherwise, packages that are required to be singletons (like React, RxJS, etc.) will break.
-                        // Reserve `module` entry for bundlers to accommodate tree-shaking.
-                        { [hasCjsFormat ? 'module' : 'import']: filePath }
-                    : filePath;
+            for (const [exportEntry, { jsFile, typesFile } ] of Object.entries(esmExports)) {
+                const originalExportsEntry = packageJson.exports[exportEntry];
+                packageJson.exports[exportEntry] = typeof originalExportsEntry === 'string' ? {} : { ...originalExportsEntry };
+                packageJson.exports[exportEntry]['import'] = {
+                    types: typesFile,
+                    default: jsFile
+                };
             }
         }
     }
     if (hasCjsFormat) {
         const cjsExports = getExports({
             ...options,
-            fileExt: '.cjs.js',
+            fileExt: (hasEsmFormat && packageJson.type === 'module') ? '.cjs' : '.js',
         });
-        packageJson.main = cjsExports['.'];
+        packageJson.main = cjsExports['.']['jsFile'];
+        packageJson.types ??= cjsExports['.']['typesFile'];
         if (!hasEsmFormat) {
             packageJson.type = 'commonjs';
         }
         if (options.generateExportsField) {
-            for (const [exportEntry, filePath] of Object.entries(cjsExports)) {
-                if (hasEsmFormat) {
-                    // If ESM format used, make sure `import` (from Node) points to a wrapped
-                    // version of CJS file to ensure the package remains a singleton.
-                    // TODO(jack): This can be made into a rollup plugin to re-use in Vite.
-                    const relativeFile = (0, path_1.parse)(filePath).base;
-                    const fauxEsmFilePath = filePath.replace(/\.cjs\.js$/, '.cjs.mjs');
-                    packageJson.exports[exportEntry]['import'] ??= fauxEsmFilePath;
-                    packageJson.exports[exportEntry]['default'] ??= filePath;
-                    // Re-export from relative CJS file, and Node will synthetically export it as ESM.
-                    // Make sure both ESM and CJS point to same instance of the package because libs like React, RxJS, etc. requires it.
-                    // Also need a special .cjs.default.js file that re-exports the `default` from CJS, or else
-                    // default import in Node will not work.
-                    (0, fs_1.writeFileSync)((0, path_1.join)(options.outputPath, filePath.replace(/\.cjs\.js$/, '.cjs.default.js')), `exports._default = require('./${(0, path_1.parse)(filePath).base}').default;`);
-                    (0, fs_1.writeFileSync)((0, path_1.join)(options.outputPath, fauxEsmFilePath),
-                    // Re-export from relative CJS file, and Node will synthetically export it as ESM.
-                    (0, devkit_1.stripIndents) `
-            export * from './${relativeFile}';
-            export { _default as default } from './${relativeFile.replace(/\.cjs\.js$/, '.cjs.default.js')}';
-            `);
-                }
-                else {
-                    packageJson.exports[exportEntry] = filePath;
-                }
+            for (const [exportEntry, { jsFile, typesFile }] of Object.entries(cjsExports)) {
+                const originalExportsEntry = packageJson.exports[exportEntry];
+                packageJson.exports[exportEntry] = typeof originalExportsEntry === 'string' ? {} : { ...originalExportsEntry };
+                packageJson.exports[exportEntry]['require'] = {
+                    types: typesFile,
+                    default: jsFile
+                };
             }
         }
     }
@@ -80,13 +65,22 @@ function getExports(options) {
         ? options.outputFileName.replace(/\.[tj]s$/, '')
         : (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
     const exports = {
-        '.': './' + mainFile + options.fileExt,
+        '.': { jsFile: './' + mainFile + options.fileExt, typesFile: getDeclarationFile(options, mainFile) },
     };
     if (options.additionalEntryPoints) {
         for (const file of options.additionalEntryPoints) {
             const { name: fileName } = (0, path_1.parse)(file);
-            exports['./' + fileName] = './' + fileName + options.fileExt;
+            exports['./' + fileName] = { jsFile: './' + fileName + options.fileExt, typesFile: getDeclarationFile(options, fileName) };
         }
     }
     return exports;
 }
+function getDeclarationFile(options, fileName) {
+    const jsExtToDeclarationExt = {
+        '.js': '.d.ts',
+        '.cjs': '.d.cts',
+        '.esm.mjs': '.esm.d.mts'
+    };
+
+    return `./${fileName}${jsExtToDeclarationExt[options.fileExt]}`;
+}
diff --git a/src/executors/rollup/rollup.impl.js b/src/executors/rollup/rollup.impl.js
index a40cdd52ebf8f428b42e8dc1fddafa99dd424191..b8b36c380d33d0ba7c04a31e0d4a16b6831f42cb 100644
--- a/src/executors/rollup/rollup.impl.js
+++ b/src/executors/rollup/rollup.impl.js
@@ -104,8 +104,12 @@ function createRollupOptions(options, dependencies, context, packageJson, source
         options.format = readCompatibleFormats(config);
     }
     return options.format.map((format, idx) => {
-        // Either we're generating only one format, so we should bundle types
-        // OR we are generating dual formats, so only bundle types for CJS.
+        let jsExtension = 'js';
+        if (format === 'esm' && packageJson.type !== 'module' && options.format.includes('cjs')) {
+            jsExtension = 'esm.mjs';
+        } else if (format === 'cjs' && packageJson.type === 'module' && options.format.includes('esm')) {
+            jsExtension = 'cjs';
+        }
         const shouldBundleTypes = options.format.length === 1 || format === 'cjs';
         const plugins = [
             copy({
@@ -121,10 +125,10 @@ function createRollupOptions(options, dependencies, context, packageJson, source
                         compilerOptions: createTsCompilerOptions(config, dependencies, options),
                     },
                 }),
-            shouldBundleTypes &&
                 (0, type_definitions_1.typeDefinitions)({
                     main: options.main,
                     projectRoot: options.projectRoot,
+                    addJsExt: jsExtension === 'esm.mjs'
                 }),
             peerDepsExternal({
                 packageJsonPath: options.project,
@@ -197,8 +201,8 @@ function createRollupOptions(options, dependencies, context, packageJson, source
                 format,
                 dir: `${options.outputPath}`,
                 name: (0, devkit_1.names)(context.projectName).className,
-                entryFileNames: `[name].${format}.js`,
-                chunkFileNames: `[name].${format}.js`,
+                entryFileNames: `[name].${jsExtension}`,
+                chunkFileNames: `[name].${jsExtension}`,
             },
             external: (id) => {
                 return externalPackages.some((name) => id === name || id.startsWith(`${name}/`)); // Could be a deep import
